在重写方法时，需要遵循以下的规则： 

(一)  父类方法的【参数列表必须完全与被子类重写的方法的参数列表相同】，否则不能称其为重写而是重载。.. 
(二)  父类的【返回类型必须与被子类重写的方法返回类型相同】，否则不能称其为重写而是重载。.. 
	补充：重写的时候，【返回值类型可以协变】
(三)  Java中规定，被子类重写的方法不能拥有比父类方法更加严格的访问权限。访问权限大小关系为：

编写过Java程序的人就知道，父类中的方法并不是在任何情况下都可以重写的，当父类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问，在子类是不能被重写的。如果定义父类的方法为public，在子类定义为private，程序运行时就会报错。例如: 

class Person
{public void print()(//public访问权限
System.out.println( "父类Person的print方法! ");
}
}
Class Stedent extends Person
{private void print()(//重写方法降低了访问权限，错误
System.out.println( "子类Student的print方法!" );
}
}

(四)  由于父类的访问权限修饰符的限制一定要大于被子类重写方法的访问权限修饰符，而private权限最小。所以如果某一个方法在父类中的访问权限是private，那么就不能在子类中对其进行重写。如果重新定义，也只是定义了一个新的方法，不会达到重写的效果。 

(五)  在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，【只能抛出IOException的子类异常】，可以抛出非检查异常。

