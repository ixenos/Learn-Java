一、在使用匿名内部类的过程中，我们需要注意如下几点：

      1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

     2、匿名内部类中是不能定义构造函数的。

     3、匿名内部类中不能存在任何的静态成员变量和静态方法。

      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

     5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。



二、我们【给匿名内部类】传递【参数】的时候，【若】【该形参】在内部类中【需要被使用】，【那么该形参必须要为final】。也就是说：当所在的方法的形参需要被内部类里面使用时，【该形参必须为final】。



【为什么】必须要为final呢？



      首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当【外部类传入的参数】需要被内部类调用时，从java程序的角度来看是直接被调用：

public class OuterClass {
    public void display(final String name,String age){ //注意形参
	//方法内部类
        class InnerClass{
            void display(){
                System.out.println(name); //匿名内部类的形参被使用，形参必须是final
            }
        }
    }
}
      从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：

public class OuterClass$InnerClass {
    public InnerClass(String name,String age){
        this.InnerClass$name = name;//将外部参数备份到自身
        this.InnerClass$age = age;
    }
    
    
    public void display(){
        System.out.println(this.InnerClass$name + "----" + this.InnerClass$age );
    }
}
      所以从上面代码来看，【内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份】，自己内部方法【调用的实际上是自己的属性】而不是外部方法传递进来的参数。

      直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说【在内部类中我对属性的改变并不会影响到外部的形参】，而然这从程序员的角度来看这是不可行的，毕竟
站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定【使用final来避免形参的不改变】。

      简单理解就是，【拷贝引用】，为了【避免引用值发生改变，例如被【外部类的方法修改等】，而导致内部类得到的值不一致，于是用final来让该引用不可改变。

      【故】如果定义了一个匿名内部类，并且希望它【使用】一个其【外部定义的参数】，那么编译器会【要求该参数引用是final】的



三、【匿名内部类初始化】

我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。

public class OutClass {
    public InnerClass getInnerClass(final int age,final String name){ //final修饰将要被内部类使用的形参，保持一致
        return new InnerClass() {
            int age_ ;
            String name_;
            //构造代码块完成初始化工作
            {				
                if(0 < age && age < 200){	//块初始化将在类加载时完成
                    age_ = age;
                    name_ = name;
                }
            }
            public String getName() {
                return name_;
            }
            
            public int getAge() {
                return age_;
            }
        };
    }
    
    public static void main(String[] args) {
        OutClass out = new OutClass();
        
        InnerClass inner_1 = out.getInnerClass(201, "chenssy");
        System.out.println(inner_1.getName());
        
        InnerClass inner_2 = out.getInnerClass(23, "chenssy");
        System.out.println(inner_2.getName());
    }
}


