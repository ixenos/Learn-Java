如果要将byte类型的数据转化成16进制来显示
因为Byte包装类没有toHexString方法，只有toString方法，而Integer有toHexString方法
所以要把byte先转换成int，
又因为byte占1个字节，8位，而int占4个字节32位，所以转换后的int前24位是0，用Oxff与去（即二进制1111 1111）


//Integer的一个方法 static String toHexString(int i)  

String s = "我勒个去";
byte[] bytes = s.getBytes();//转换成字节序列，用项目默认的编码GBK, s.getBytes()得到的是GBK编码，是十进制
for(byte b: bytes)//foreach遍历
{
	//!!!【0xff是byte】一个byte跟0xff相与来运算，【结果高的24个比特就不会取到】

	System.out.println( Integer.toHexString(b & 0xff) + " ");
}

【0x是十六进制，一个0就是4位，f就是1111 ff就是1111 1111】
【移位运算符是对于二进制来说的 eg。3<<2 是指 0000 0011 <<2 是 0000 1100】




【//int转byte时:】
public static void main(String args[])
{
int a=2;
byte[]b=new b[4];       //int 4个字节 32位 byte 1个字节 8位
b[0]=(byte)(a>>24);	//【高八位右移24位 32位的第一个高八位存进byte数组，所以削掉后面的24位,前面补上的24位也被切掉了】
b[1]=(byte)(a>>16);	//次高八位右移16位 高八位补位和后十六位被削
b[2]=(byte)(a>>8);	//次低八位右移8位 高16位补位和低八位被削掉
b[3]=(byte)(a);		//自动削掉前24位
System.out.println(b[0]+""+b[1]+""+b[2]+""+b[3]);  //这样打印出来看起来就是32位
}

【//byte转回int时:】
System.out.println(((b[0]&0x000000ff)<<24)|((b[1]&0x000000ff)<<16)|((byte[2]&0x000000ff)<<8)|(byte[3]&0x000000ff));
//【&Ox000000ff是给byte补位成int】【0x为十六进制，一个数字4位，添6个0，从八位补到32位，然后左移到自己的位置上，最后|取并集】




在剖析该问题前请看如下代码
public static String bytes2HexString(byte[] b) {
  String ret = "";
  for (int i = 0; i < b.length; i++) {
   String hex = Integer.toHexString(b[ i ] & 0xFF);
   if (hex.length() == 1) {
    hex = '0' + hex;
   }
   ret += hex.toUpperCase();
  }
  return ret;
}
上面是将byte[]转化十六进制的字符串,注意这里b[ i ] & 0xFF将一个byte和 0xFF进行了与运算,然后使用Integer.toHexString取得了十六进制字符串,可以看出
b[ i ] & 0xFF运算后得出的仍然是个int,本来低位转高位系统就能自动转换了，【那么为何要和 0xFF进行与运算呢?】直接 Integer.toHexString(b[ i ]);,将byte强转为int不行吗?答案是不行的.

其原因在于:
1.byte的大小为8bits而int的大小为32bits
2.java的二进制采用的是【补码】形式，这是最关键的地方 





在这里先温习下计算机基础理论

byte是一个字节保存的，有8个位，即8个0、1。
8位的第一个位是符号位， 
也就是说0000 0001代表的是数字1 
1000 0000代表的就是-1 
所以正数最大位0111 1111，也就是数字127 
负数最大为1111 1111，也就是数字-128

上面说的是二进制原码，但是在java中采用的是补码的形式，下面介绍下什么是补码

1、反码：
        一个数如果是正，则它的反码与原码相同；
        一个数如果是负，则符号位为1，其余各位是对原码取反；

2、补码：利用溢出，我们可以将减法变成加法
       对于十进制数，从9得到5可用减法：
       9－4＝5    因为4+6＝10，我们可以将6作为4的补数
       改写为加法：
       9+6＝15（去掉高位1，也就是减10）得到5.

       对于十六进制数，从c到5可用减法：
       c－7＝5    因为7+9＝16 将9作为7的补数
       改写为加法：
       c+9＝15（去掉高位1，也就是减16）得到5.

    在计算机中，如果我们用1个字节表示一个数，一个字节有8位，超过8位就进1，在内存中情况为（100000000），进位1被丢弃。

    ⑴一个数为正，则它的原码、反码、补码相同
    ⑵一个数为负，刚符号位为1，其余各位是对原码取反，然后整个数加1
    
- 1的原码为                10000001
- 1的反码为                11111110
                                                   + 1
- 1的补码为                11111111

0的原码为                 00000000
0的反码为                 11111111（正零和负零的反码相同）
                                          +1
0的补码为               100000000（舍掉打头的1，正零和负零的补码相同）




【Integer.toHexString的参数是int】，如果不进行&0xff，那么【当一个byte强制转换成int时】，由于int是32位，而byte只有8位这时会进行补位，
例如补码11111111的十进制数为-1转换为int时变为11111111111111111111111111111111好多1啊，呵呵！即0xffffffff但是这个数是不对的，这种补位就会造成误差。
和0xff相与后，高24比特就会被清0了，结果就对了。



----------------------------------------------------
Java中的一个byte，其范围是-128~127的，而Integer.toHexString的参数本来是int，如果不进行&0xff，那么当一个byte会转换成int时，【对于负数，会做位扩展】，举例来说，一个byte的-1（即0xff），会被转换成int的-1（即0xffffffff），那么转化出的结果就不是我们想要的了。

而【0xff默认是整形】，所以，一个byte跟0xff相与【会先将那个byte转化成整形】来运算，这样，【结果中的高的24个比特就总会被清0】，于是结果总是我们想要的。