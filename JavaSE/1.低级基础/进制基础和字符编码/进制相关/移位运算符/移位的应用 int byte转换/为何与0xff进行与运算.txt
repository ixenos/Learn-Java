为何与0xff进行与运算

在剖析该问题前请看如下代码

public static String bytes2HexString(byte[] b) {

  String ret = "";

  for (int i = 0; i < b.length; i++) {

   String hex = Integer.toHexString(b[ i ] & 0xFF);

   if (hex.length() == 1) {

    hex = '0' + hex;

   }

   ret += hex.toUpperCase();

  }

  使用以下的语句,就可以区分使用&0xff和不使用的区别了

  System.out.println(Integer.toBinaryString(b & 0xff)); 输出结果:000000000000000000000000 11010110

  System.out.println(Integer.toBinaryString(b)); 输出结果:       111111111111111111111111 11010110

  return ret;

}

代码解析:

注意这里b[ i ] & 0xFF将一个byte和 0xFF进行了与运算。

b[ i ] & 0xFF运算后得出的仍然是个int,那么为何要和 0xFF进行与运算呢?直接 Integer.toHexString(b[ i ]);

将byte强转为int不行吗?答案是不行的.

其原因在于:

1.byte的大小为8bits而int的大小为32bits

2.java的二进制采用的是补码形式

byte是一个字节保存的,有8个位,即8个0、1。

8位的第一个位是符号位,

也就是说0000 0001代表的是数字1

1000 0000代表的就是-1

所以正数最大位0111 1111,也就是数字127

负数最大为1111 1111,也就是数字-128

上面说的是二进制原码,但是在java中采用的是补码的形式,下面介绍下什么是补码

1、反码:

一个数如果是正,则它的反码与原码相同;

    一个数如果是负,则符号位为1,其余各位是对原码取反;

举个例子:2 二进制吗为 00000010,因为是正数,所以其反码也是 00000010

如果是-2那么,就要把最高位变为1,其他7位按照其正数的位置取反。

2、补码:利用溢出,我们可以将减法变成加法:

对于十进制数,从9得到5可用减法:

    9-4=5    因为4+6=10,我们可以将6作为4的补数

    改写为加法:

    +6=15(去掉高位1,也就是减10)得到5.

    对于十六进制数,从c到5可用减法:

    c-7=5    因为7+9=16 将9作为7的补数

    改写为加法:

    c+9=15(去掉高位1,也就是减16)得到5.

在计算机中,如果我们用1个字节表示一个数,一个字节有8位,超过8位就进1,在内存中情况为(100000000),进位1被丢弃。

⑴一个数为正,则它的原码、反码、补码相同

⑵一个数为负,刚符号位为1,其余各位是对原码取反,然后整个数加1

- 1的原码为                10000001

- 1的反码为                11111110

                                                   + 1

- 1的补码为                11111111

0的原码为                  00000000

0的反码为                  11111111(正零和负零的反码相同)

                                          +1

0的补码为                  100000000(舍掉打头的1,正零和负零的补码相同)

Integer.toHexString的参数是int,【如果不进行&0xff,那么当一个byte会转换成int时,由于int是32位,

而byte只有8位这时会进行补位,例如补码11111111的十进制数为-1

转换为int时变为11111111 11111111 11111111 11111111好多1啊,呵呵!】

即0xffffffff但是这个数是不对的,这种补位就会造成误差。

【和0xff相与后,高24比特就会被清0了】,结果就对了。

Java中的一个byte,其范围是-128~127的,而Integer.toHexString的参数本来是int,如果不进行&0xff,

那么当一个byte会转换成int时,【对于负数,会做位扩展】,举例来说,一个byte的-1(即0xff),

会被转换成int的-1(即0xffffffff),那么转化出的结果就不是我们想要的了。

而0xff默认是整形,所以,一个byte跟0xff相与会先将那个byte转化成整形运算,这样,

结果中的高的24个比特就总会被清0,于是结果总是我们想要的。

0xFF (十进制1)

二进制码:00000000 00000000 00000000 11111111

与 0xff 做 & 运算会将 byte 值变成 int 类型的值,也将 -128~0 间的负值都转成正值了。

char c = (char)-1 & 0xFF;

char d = (char)-1;

System.out.println((int)c); 255

System.out.println((int)d); 65535

java中的抵凳int,所以0xFF是int,而byte是有符,int亦然,直接由byte升int,符自U展,

而M行了& 0xFF後,就把符}忽略掉了,byte以0/1地引用其热,所以要0xFF,不是多N的,

你用一些Streamx取文件的byte就知道了,我昨天搞了一天,就不明白槭颤Nx出淼的承byte

在移位後e`的,就是因檫@原因.

把number转换为二进制,只取最低的8位(bit)。因为0xff二进制就是1111 1111

& 运算是,如果对应的两个bit都是1,则那个bit结果为1,否则为0.

比如 1010 & 1101 = 1000 (二进制)

由于0xff最低的8位是1,因此number中低8位中的&之后,如果原来是1,结果还是1,原来是0,结果位还

是0.高于8位的,0xff都是0,所以无论是0还是1,结果都是0.



注意一点！！！正数的补码和反码跟原码是一样的！！！所以以上所有的特殊都是针对负数来说的！！！