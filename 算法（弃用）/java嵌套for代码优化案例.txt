1 案例描述 
某日，在JavaEye上看到一道面试题，题目是这样的：请对以下的代码进行优化 
Java代码  
for (int i = 0; i < 1000; i++) 
for (int j = 0; j < 100; j++) 
for (int k = 0; k < 10; k++) 
testFunction (i, j, k); 

（注：为了同后面的内容一致，这里对原题目进行了部分修改） 

2 案例分析 
从给出的代码可知，不论如何优化，testFunction执行的次数都是相同的，该部分不存在优化的可能。那么，代码的优化只能从循环变量i、j、k的实例化、初始化、比较、自增等方面的耗时上进行分析。 
首先，我们先分析原题代码循环变量在实例化、初始化、比较、自增等方面的耗时情况： 

变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) 
i 1 1 1000 1000 
j 1000 1000 1000 * 100 1000 * 100 
k 1000 * 100 1000 * 100 1000 * 100 * 10 1000 * 100 * 10 

（注：由于单次耗时视不同机器配置而不同，上表相关耗时采用处理的次数进行说明） 
该代码的性能优化就是尽可能减少循环变量i、j、k的实例化、初始化、比较、自增的次数，同时，不能引进其它可能的运算耗时。 

3 解决过程 
从案例分析，对于原题代码，我们提出有两种优化方案： 
3.1 优化方案一 
代码如下： 
Java代码  
for (int i = 0; i < 10; i++) 
for (int j = 0; j < 100; j++) 
for (int k = 0; k < 1000; k++) 
testFunction (k, j, i); 

该方案主要是将循环次数最少的放到外面，循环次数最多的放里面，这样可以最大程度的（注：3个不同次数的循环变量共有6种排列组合情况，此种组合为最优）减少相关循环变量的实例化次数、初始化次数、比较次数、自增次数，方案耗时情况如下： 

变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) 
i 1 1 10 10 
j 10 10 10 * 100 10 * 100 
k 10 * 100 10 * 100 10 * 100 * 1000 10 * 100 * 1000 


3.2 优化方案二 
代码如下： 
Java代码  
int i, j, k; 
for (i = 0; i < 10; i++) 
for (j = 0; j < 100; j++) 
for (k = 0; k < 1000; k++) 
testFunction (k, j, i); 

该方案在方案一的基础上，将循环变量的实例化放到循环外，这样可以进一步减少相关循环变量的实例化次数，方案耗时情况如下： 

变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) 
i 1 1 10 10 
j 1 10 10 * 100 10 * 100 
k 1 10 * 100 10 * 100 * 1000 10 * 100 * 1000 


4 解决结果 
那么，提出的优化方案是否如我们分析的那样有了性能上的提升了呢？我们编写一些测试代码进行验证，数据更能说明我们的优化效果。 
4.1 测试代码 
Java代码  
public static void testFunction(int i, int j, int k) { 
System.out.print(""); // 注：该方法不影响整体优化，这里只有简单输出 
} 

public static void testA() { 
long start = System.nanoTime(); 
for (int i = 0; i < 1000; i++) 
for (int j = 0; j < 100; j++) 
for (int k = 0; k < 10; k++) 
testFunction(i, j, k); 
System.out.println("testA time>>" + (System.nanoTime() - start)); 
} 

public static void testB() { 
long start = System.nanoTime(); 
for (int i = 0; i < 10; i++) 
for (int j = 0; j < 100; j++) 
for (int k = 0; k < 1000; k++) 
testFunction(k, j, i); 
System.out.println("testB time>>" + (System.nanoTime() - start)); 
} 

public static void testC() { 
long start = System.nanoTime(); 
int i; 
int j; 
int k; 
for (i = 0; i < 10; i++) 
for (j = 0; j < 100; j++) 
for (k = 0; k < 1000; k++) 
testFunction(k, j, i); 
System.out.println("testC time>>" + (System.nanoTime() - start)); 
} 

4.2 测试结果 
1、测试机器配置：Pentium(R) Dual-Core CPU E5400 @2.70GHz 2.70GHz, 2GB内存； 
2、循环变量i、j、k循环次数分别为10、100、1000，进行5组测试，测试结果如下： 

第1组 第2组 第3组 第4组 第5组 
原方案 171846271 173250166 173910870 173199875 173725328 
方案一 168839312 168466660 168372616 168310190 168041251 
方案二 168001838 169141906 168230655 169421766 168240748 

从上面的测试结果来看，优化后的方案明显性能优于原方案，达到了优化的效果。但优化方案二并没有如我们预期的优于方案一，其中第2、4、5组的数据更是比方案一差，怀疑可能是循环次数太少，以及测试环境相关因素影响下出现的结果。 

3、重新调整循环变量i、j、k循环次数分别为20、200、2000，进行5组测试，测试结果如下： 

第1组 第2组 第3组 第4组 第5组 
原方案 1355397203 1358978176 1358128281 1350193682 1354786598 
方案一 1343482704 1348410388 1343978037 1347919156 1340697793 
方案二 1342427528 1343897887 1342662462 1342124048 1336266453 

从上面的测试结果来看，优化后的方案基本符合我们的预期结果。 

5 总结 
从案例分析和解决过程中的三个表的分析可知，优化方案一和优化方案二的性能都比原代码的性能好，其中优化方案二的性能是最好的。在嵌套For循环中，将循环次数多的循环放在内侧，循环次数少的循环放在外侧，其性能会提高；减少循环变量的实例化，其性能也会提高。从测试数据可知，对于两种优化方案，如果在循环次数较少的情况下，其运行效果区别不大；但在循环次数较多的情况下，其效果就比较明显了。